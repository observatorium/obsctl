// Package fetcher provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package fetcher

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/ghodss/yaml"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/go-chi/chi/v5"
)

// Defines values for AlertingRuleEvaluatedType.
const (
	AlertingRuleEvaluatedTypeAlerting AlertingRuleEvaluatedType = "alerting"
)

// Defines values for InstantQueryResponseResultType.
const (
	InstantQueryResponseResultTypeMatrix InstantQueryResponseResultType = "matrix"

	InstantQueryResponseResultTypeScalar InstantQueryResponseResultType = "scalar"

	InstantQueryResponseResultTypeString InstantQueryResponseResultType = "string"

	InstantQueryResponseResultTypeVector InstantQueryResponseResultType = "vector"
)

// Defines values for RangeQueryResponseResultType.
const (
	RangeQueryResponseResultTypeMatrix RangeQueryResponseResultType = "matrix"
)

// Defines values for RecordingRuleEvaluatedType.
const (
	RecordingRuleEvaluatedTypeRecording RecordingRuleEvaluatedType = "recording"
)

// ActiveAlert defines model for ActiveAlert.
type ActiveAlert struct {
	ActiveAt    string                   `json:"activeAt"`
	Annotations *ActiveAlert_Annotations `json:"annotations,omitempty"`
	Labels      *ActiveAlert_Labels      `json:"labels,omitempty"`
	State       string                   `json:"state"`
	Value       string                   `json:"value"`
}

// ActiveAlert_Annotations defines model for ActiveAlert.Annotations.
type ActiveAlert_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ActiveAlert_Labels defines model for ActiveAlert.Labels.
type ActiveAlert_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AlertingRule defines model for AlertingRule.
type AlertingRule struct {
	Alert       string                    `json:"alert"`
	Annotations *AlertingRule_Annotations `json:"annotations,omitempty"`
	Expr        string                    `json:"expr"`
	For         *string                   `json:"for,omitempty"`
	Labels      *AlertingRule_Labels      `json:"labels,omitempty"`
}

// AlertingRule_Annotations defines model for AlertingRule.Annotations.
type AlertingRule_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AlertingRule_Labels defines model for AlertingRule.Labels.
type AlertingRule_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AlertingRuleEvaluated defines model for AlertingRuleEvaluated.
type AlertingRuleEvaluated struct {
	Alerts         *[]ActiveAlert                     `json:"alerts,omitempty"`
	Annotations    *AlertingRuleEvaluated_Annotations `json:"annotations,omitempty"`
	Duration       *float32                           `json:"duration,omitempty"`
	EvaluationTime *float32                           `json:"evaluationTime,omitempty"`
	Health         *string                            `json:"health,omitempty"`
	Labels         *AlertingRuleEvaluated_Labels      `json:"labels,omitempty"`
	LastEvaluation *string                            `json:"lastEvaluation,omitempty"`
	Name           string                             `json:"name"`
	Query          string                             `json:"query"`
	Type           *AlertingRuleEvaluatedType         `json:"type,omitempty"`
}

// AlertingRuleEvaluated_Annotations defines model for AlertingRuleEvaluated.Annotations.
type AlertingRuleEvaluated_Annotations struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AlertingRuleEvaluated_Labels defines model for AlertingRuleEvaluated.Labels.
type AlertingRuleEvaluated_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AlertingRuleEvaluatedType defines model for AlertingRuleEvaluated.Type.
type AlertingRuleEvaluatedType string

// InstantQueryResponse defines model for InstantQueryResponse.
type InstantQueryResponse struct {
	Result     []interface{}                  `json:"result"`
	ResultType InstantQueryResponseResultType `json:"resultType"`
}

// InstantQueryResponseResultType defines model for InstantQueryResponse.ResultType.
type InstantQueryResponseResultType string

// InstantVectors defines model for InstantVectors.
type InstantVectors struct {
	Metric InstantVectors_Metric `json:"metric"`
	Values ScalarOrString        `json:"values"`
}

// InstantVectors_Metric defines model for InstantVectors.Metric.
type InstantVectors_Metric struct {
	AdditionalProperties map[string]string `json:"-"`
}

// LabelValuesResponse defines model for LabelValuesResponse.
type LabelValuesResponse struct {
	Data      *[]string `json:"data,omitempty"`
	Error     *string   `json:"error,omitempty"`
	ErrorType *string   `json:"errorType,omitempty"`
	Status    string    `json:"status"`
	Warnings  *[]string `json:"warnings,omitempty"`
}

// LabelsResponse defines model for LabelsResponse.
type LabelsResponse struct {
	Data      *[]string `json:"data,omitempty"`
	Error     *string   `json:"error,omitempty"`
	ErrorType *string   `json:"errorType,omitempty"`
	Status    string    `json:"status"`
	Warnings  *[]string `json:"warnings,omitempty"`
}

// QueryRangeResponse defines model for QueryRangeResponse.
type QueryRangeResponse struct {
	Data      *RangeQueryResponse `json:"data,omitempty"`
	Error     *string             `json:"error,omitempty"`
	ErrorType *string             `json:"errorType,omitempty"`
	Status    string              `json:"status"`
	Warnings  *[]string           `json:"warnings,omitempty"`
}

// QueryResponse defines model for QueryResponse.
type QueryResponse struct {
	Data      *InstantQueryResponse `json:"data,omitempty"`
	Error     *string               `json:"error,omitempty"`
	ErrorType *string               `json:"errorType,omitempty"`
	Status    string                `json:"status"`
	Warnings  *[]string             `json:"warnings,omitempty"`
}

// RangeQueryResponse defines model for RangeQueryResponse.
type RangeQueryResponse struct {
	Result     []interface{}                `json:"result"`
	ResultType RangeQueryResponseResultType `json:"resultType"`
}

// RangeQueryResponseResultType defines model for RangeQueryResponse.ResultType.
type RangeQueryResponseResultType string

// RangeVectors defines model for RangeVectors.
type RangeVectors struct {
	Metric RangeVectors_Metric `json:"metric"`
	Values []ScalarOrString    `json:"values"`
}

// RangeVectors_Metric defines model for RangeVectors.Metric.
type RangeVectors_Metric struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RecordingRule defines model for RecordingRule.
type RecordingRule struct {
	Expr   string                `json:"expr"`
	Labels *RecordingRule_Labels `json:"labels,omitempty"`
	Record string                `json:"record"`
}

// RecordingRule_Labels defines model for RecordingRule.Labels.
type RecordingRule_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RecordingRuleEvaluated defines model for RecordingRuleEvaluated.
type RecordingRuleEvaluated struct {
	EvaluationTime *float32                       `json:"evaluationTime,omitempty"`
	Health         *string                        `json:"health,omitempty"`
	Labels         *RecordingRuleEvaluated_Labels `json:"labels,omitempty"`
	LastEvaluation *string                        `json:"lastEvaluation,omitempty"`
	Name           string                         `json:"name"`
	Query          string                         `json:"query"`
	Type           *RecordingRuleEvaluatedType    `json:"type,omitempty"`
}

// RecordingRuleEvaluated_Labels defines model for RecordingRuleEvaluated.Labels.
type RecordingRuleEvaluated_Labels struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RecordingRuleEvaluatedType defines model for RecordingRuleEvaluated.Type.
type RecordingRuleEvaluatedType string

// RuleGroup defines model for RuleGroup.
type RuleGroup struct {
	Interval *float32      `json:"interval,omitempty"`
	Name     string        `json:"name"`
	Rules    []interface{} `json:"rules"`
}

// RuleGroupEvaluated defines model for RuleGroupEvaluated.
type RuleGroupEvaluated struct {
	EvaluationTime          *float32      `json:"evaluationTime,omitempty"`
	File                    *string       `json:"file,omitempty"`
	Interval                *float32      `json:"interval,omitempty"`
	LastEvaluation          *string       `json:"lastEvaluation,omitempty"`
	Limit                   *float32      `json:"limit,omitempty"`
	Name                    string        `json:"name"`
	PartialResponseStrategy *string       `json:"partialResponseStrategy,omitempty"`
	Rules                   []interface{} `json:"rules"`
}

// Rules defines model for Rules.
type Rules struct {
	Groups []RuleGroupEvaluated `json:"groups"`
}

// RulesRaw defines model for RulesRaw.
type RulesRaw struct {
	Groups []RuleGroup `json:"groups"`
}

// RulesResponse defines model for RulesResponse.
type RulesResponse struct {
	Data      *Rules    `json:"data,omitempty"`
	Error     *string   `json:"error,omitempty"`
	ErrorType *string   `json:"errorType,omitempty"`
	Status    string    `json:"status"`
	Warnings  *[]string `json:"warnings,omitempty"`
}

// ScalarOrString defines model for ScalarOrString.
type ScalarOrString []interface{}

// SeriesResponse defines model for SeriesResponse.
type SeriesResponse struct {
	Data *[]struct {
		AdditionalProperties map[string]string `json:"-"`
	} `json:"data,omitempty"`
	Error     *string   `json:"error,omitempty"`
	ErrorType *string   `json:"errorType,omitempty"`
	Status    string    `json:"status"`
	Warnings  *[]string `json:"warnings,omitempty"`
}

// GetLabelValuesParams defines parameters for GetLabelValues.
type GetLabelValuesParams struct {
	// Repeated series selector argument
	Match *[]string `json:"match[],omitempty"`

	// Start timestamp
	Start *string `json:"start,omitempty"`

	// End timestamp
	End *string `json:"end,omitempty"`
}

// GetLabelsParams defines parameters for GetLabels.
type GetLabelsParams struct {
	// Repeated series selector argument
	Match *[]string `json:"match[],omitempty"`

	// Start timestamp
	Start *string `json:"start,omitempty"`

	// End timestamp
	End *string `json:"end,omitempty"`
}

// GetInstantQueryParams defines parameters for GetInstantQuery.
type GetInstantQueryParams struct {
	// query to fetch result for
	Query *string `json:"query,omitempty"`

	// Evaluation timestamp
	Time *string `json:"time,omitempty"`

	// Evaluation timeout
	Timeout *string `json:"timeout,omitempty"`
}

// GetRangeQueryParams defines parameters for GetRangeQuery.
type GetRangeQueryParams struct {
	// query to fetch result for
	Query *string `json:"query,omitempty"`

	// Start timestamp
	Start *string `json:"start,omitempty"`

	// End timestamp
	End *string `json:"end,omitempty"`

	// Query resolution step width
	Step *string `json:"step,omitempty"`

	// Evaluation timeout
	Timeout *string `json:"timeout,omitempty"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	// type of Rules
	Type *string `json:"type,omitempty"`

	// Repeated label selector argument
	Match *[]string `json:"match[],omitempty"`
}

// GetSeriesParams defines parameters for GetSeries.
type GetSeriesParams struct {
	// Repeated series selector argument
	Match *[]string `json:"match[],omitempty"`

	// Start timestamp
	Start *string `json:"start,omitempty"`

	// End timestamp
	End *string `json:"end,omitempty"`
}

// Getter for additional properties for ActiveAlert_Annotations. Returns the specified
// element and whether it was found
func (a ActiveAlert_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActiveAlert_Annotations
func (a *ActiveAlert_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActiveAlert_Annotations to handle AdditionalProperties
func (a *ActiveAlert_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActiveAlert_Annotations to handle AdditionalProperties
func (a ActiveAlert_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActiveAlert_Labels. Returns the specified
// element and whether it was found
func (a ActiveAlert_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActiveAlert_Labels
func (a *ActiveAlert_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActiveAlert_Labels to handle AdditionalProperties
func (a *ActiveAlert_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActiveAlert_Labels to handle AdditionalProperties
func (a ActiveAlert_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AlertingRule_Annotations. Returns the specified
// element and whether it was found
func (a AlertingRule_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AlertingRule_Annotations
func (a *AlertingRule_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AlertingRule_Annotations to handle AdditionalProperties
func (a *AlertingRule_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AlertingRule_Annotations to handle AdditionalProperties
func (a AlertingRule_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AlertingRule_Labels. Returns the specified
// element and whether it was found
func (a AlertingRule_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AlertingRule_Labels
func (a *AlertingRule_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AlertingRule_Labels to handle AdditionalProperties
func (a *AlertingRule_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AlertingRule_Labels to handle AdditionalProperties
func (a AlertingRule_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AlertingRuleEvaluated_Annotations. Returns the specified
// element and whether it was found
func (a AlertingRuleEvaluated_Annotations) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AlertingRuleEvaluated_Annotations
func (a *AlertingRuleEvaluated_Annotations) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AlertingRuleEvaluated_Annotations to handle AdditionalProperties
func (a *AlertingRuleEvaluated_Annotations) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AlertingRuleEvaluated_Annotations to handle AdditionalProperties
func (a AlertingRuleEvaluated_Annotations) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AlertingRuleEvaluated_Labels. Returns the specified
// element and whether it was found
func (a AlertingRuleEvaluated_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AlertingRuleEvaluated_Labels
func (a *AlertingRuleEvaluated_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AlertingRuleEvaluated_Labels to handle AdditionalProperties
func (a *AlertingRuleEvaluated_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AlertingRuleEvaluated_Labels to handle AdditionalProperties
func (a AlertingRuleEvaluated_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for InstantVectors_Metric. Returns the specified
// element and whether it was found
func (a InstantVectors_Metric) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InstantVectors_Metric
func (a *InstantVectors_Metric) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InstantVectors_Metric to handle AdditionalProperties
func (a *InstantVectors_Metric) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InstantVectors_Metric to handle AdditionalProperties
func (a InstantVectors_Metric) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RangeVectors_Metric. Returns the specified
// element and whether it was found
func (a RangeVectors_Metric) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RangeVectors_Metric
func (a *RangeVectors_Metric) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RangeVectors_Metric to handle AdditionalProperties
func (a *RangeVectors_Metric) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RangeVectors_Metric to handle AdditionalProperties
func (a RangeVectors_Metric) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RecordingRule_Labels. Returns the specified
// element and whether it was found
func (a RecordingRule_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RecordingRule_Labels
func (a *RecordingRule_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RecordingRule_Labels to handle AdditionalProperties
func (a *RecordingRule_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RecordingRule_Labels to handle AdditionalProperties
func (a RecordingRule_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RecordingRuleEvaluated_Labels. Returns the specified
// element and whether it was found
func (a RecordingRuleEvaluated_Labels) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RecordingRuleEvaluated_Labels
func (a *RecordingRuleEvaluated_Labels) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RecordingRuleEvaluated_Labels to handle AdditionalProperties
func (a *RecordingRuleEvaluated_Labels) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RecordingRuleEvaluated_Labels to handle AdditionalProperties
func (a RecordingRuleEvaluated_Labels) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetLabelValues request
	GetLabelValues(ctx context.Context, tenant string, labelName string, params *GetLabelValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabels request
	GetLabels(ctx context.Context, tenant string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantQuery request
	GetInstantQuery(ctx context.Context, tenant string, params *GetInstantQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRangeQuery request
	GetRangeQuery(ctx context.Context, tenant string, params *GetRangeQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, tenant string, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRawRules request
	GetRawRules(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRawRules request with any body
	SetRawRulesWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeries request
	GetSeries(ctx context.Context, tenant string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetLabelValues(ctx context.Context, tenant string, labelName string, params *GetLabelValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelValuesRequest(c.Server, tenant, labelName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabels(ctx context.Context, tenant string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantQuery(ctx context.Context, tenant string, params *GetInstantQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantQueryRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRangeQuery(ctx context.Context, tenant string, params *GetRangeQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRangeQueryRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, tenant string, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRawRules(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRawRulesRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRawRulesWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRawRulesRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeries(ctx context.Context, tenant string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetLabelValuesRequest generates requests for GetLabelValues
func NewGetLabelValuesRequest(server string, tenant string, labelName string, params *GetLabelValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "label_name", runtime.ParamLocationPath, labelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/label/%s/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Match != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match[]", runtime.ParamLocationQuery, *params.Match); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelsRequest generates requests for GetLabels
func NewGetLabelsRequest(server string, tenant string, params *GetLabelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/labels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Match != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match[]", runtime.ParamLocationQuery, *params.Match); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantQueryRequest generates requests for GetInstantQuery
func NewGetInstantQueryRequest(server string, tenant string, params *GetInstantQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Time != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRangeQueryRequest generates requests for GetRangeQuery
func NewGetRangeQueryRequest(server string, tenant string, params *GetRangeQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/query_range", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Step != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Timeout != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, tenant string, params *GetRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Match != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match[]", runtime.ParamLocationQuery, *params.Match); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRawRulesRequest generates requests for GetRawRules
func NewGetRawRulesRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/rules/raw", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRawRulesRequestWithBody generates requests for SetRawRules with any type of body
func NewSetRawRulesRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/rules/raw", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSeriesRequest generates requests for GetSeries
func NewGetSeriesRequest(server string, tenant string, params *GetSeriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/metrics/v1/%s/api/v1/series", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Match != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "match[]", runtime.ParamLocationQuery, *params.Match); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetLabelValues request
	GetLabelValuesWithResponse(ctx context.Context, tenant string, labelName string, params *GetLabelValuesParams, reqEditors ...RequestEditorFn) (*GetLabelValuesResponse, error)

	// GetLabels request
	GetLabelsWithResponse(ctx context.Context, tenant string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error)

	// GetInstantQuery request
	GetInstantQueryWithResponse(ctx context.Context, tenant string, params *GetInstantQueryParams, reqEditors ...RequestEditorFn) (*GetInstantQueryResponse, error)

	// GetRangeQuery request
	GetRangeQueryWithResponse(ctx context.Context, tenant string, params *GetRangeQueryParams, reqEditors ...RequestEditorFn) (*GetRangeQueryResponse, error)

	// GetRules request
	GetRulesWithResponse(ctx context.Context, tenant string, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// GetRawRules request
	GetRawRulesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetRawRulesResponse, error)

	// SetRawRules request with any body
	SetRawRulesWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRawRulesResponse, error)

	// GetSeries request
	GetSeriesWithResponse(ctx context.Context, tenant string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*GetSeriesResponse, error)
}

type GetLabelValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabelValuesResponse
}

// Status returns HTTPResponse.Status
func (r GetLabelValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *LabelsResponse
}

// Status returns HTTPResponse.Status
func (r GetLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *QueryResponse
}

// Status returns HTTPResponse.Status
func (r GetInstantQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *QueryRangeResponse
}

// Status returns HTTPResponse.Status
func (r GetRangeQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *RulesResponse
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRawRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *RulesRaw
}

// Status returns HTTPResponse.Status
func (r GetRawRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRawRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRawRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRawRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRawRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *SeriesResponse
}

// Status returns HTTPResponse.Status
func (r GetSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetLabelValuesWithResponse request returning *GetLabelValuesResponse
func (c *ClientWithResponses) GetLabelValuesWithResponse(ctx context.Context, tenant string, labelName string, params *GetLabelValuesParams, reqEditors ...RequestEditorFn) (*GetLabelValuesResponse, error) {
	rsp, err := c.GetLabelValues(ctx, tenant, labelName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelValuesResponse(rsp)
}

// GetLabelsWithResponse request returning *GetLabelsResponse
func (c *ClientWithResponses) GetLabelsWithResponse(ctx context.Context, tenant string, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error) {
	rsp, err := c.GetLabels(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelsResponse(rsp)
}

// GetInstantQueryWithResponse request returning *GetInstantQueryResponse
func (c *ClientWithResponses) GetInstantQueryWithResponse(ctx context.Context, tenant string, params *GetInstantQueryParams, reqEditors ...RequestEditorFn) (*GetInstantQueryResponse, error) {
	rsp, err := c.GetInstantQuery(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantQueryResponse(rsp)
}

// GetRangeQueryWithResponse request returning *GetRangeQueryResponse
func (c *ClientWithResponses) GetRangeQueryWithResponse(ctx context.Context, tenant string, params *GetRangeQueryParams, reqEditors ...RequestEditorFn) (*GetRangeQueryResponse, error) {
	rsp, err := c.GetRangeQuery(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeQueryResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, tenant string, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// GetRawRulesWithResponse request returning *GetRawRulesResponse
func (c *ClientWithResponses) GetRawRulesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetRawRulesResponse, error) {
	rsp, err := c.GetRawRules(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRawRulesResponse(rsp)
}

// SetRawRulesWithBodyWithResponse request with arbitrary body returning *SetRawRulesResponse
func (c *ClientWithResponses) SetRawRulesWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRawRulesResponse, error) {
	rsp, err := c.SetRawRulesWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRawRulesResponse(rsp)
}

// GetSeriesWithResponse request returning *GetSeriesResponse
func (c *ClientWithResponses) GetSeriesWithResponse(ctx context.Context, tenant string, params *GetSeriesParams, reqEditors ...RequestEditorFn) (*GetSeriesResponse, error) {
	rsp, err := c.GetSeries(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesResponse(rsp)
}

// ParseGetLabelValuesResponse parses an HTTP response from a GetLabelValuesWithResponse call
func ParseGetLabelValuesResponse(rsp *http.Response) (*GetLabelValuesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabelValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLabelsResponse parses an HTTP response from a GetLabelsWithResponse call
func ParseGetLabelsResponse(rsp *http.Response) (*GetLabelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest LabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetInstantQueryResponse parses an HTTP response from a GetInstantQueryWithResponse call
func ParseGetInstantQueryResponse(rsp *http.Response) (*GetInstantQueryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest QueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetRangeQueryResponse parses an HTTP response from a GetRangeQueryWithResponse call
func ParseGetRangeQueryResponse(rsp *http.Response) (*GetRangeQueryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRangeQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest QueryRangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest RulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetRawRulesResponse parses an HTTP response from a GetRawRulesWithResponse call
func ParseGetRawRulesResponse(rsp *http.Response) (*GetRawRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRawRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest RulesRaw
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSetRawRulesResponse parses an HTTP response from a SetRawRulesWithResponse call
func ParseSetRawRulesResponse(rsp *http.Response) (*SetRawRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRawRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSeriesResponse parses an HTTP response from a GetSeriesWithResponse call
func ParseGetSeriesResponse(rsp *http.Response) (*GetSeriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest SeriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get label values for a tenant
	// (GET /api/metrics/v1/{tenant}/api/v1/label/{label_name}/values)
	GetLabelValues(w http.ResponseWriter, r *http.Request, tenant string, labelName string, params GetLabelValuesParams)
	// Get all labels for a tenant
	// (GET /api/metrics/v1/{tenant}/api/v1/labels)
	GetLabels(w http.ResponseWriter, r *http.Request, tenant string, params GetLabelsParams)
	// Evaluate instant queries for a tenant
	// (GET /api/metrics/v1/{tenant}/api/v1/query)
	GetInstantQuery(w http.ResponseWriter, r *http.Request, tenant string, params GetInstantQueryParams)
	// Evaluate range queries for a tenant
	// (GET /api/metrics/v1/{tenant}/api/v1/query_range)
	GetRangeQuery(w http.ResponseWriter, r *http.Request, tenant string, params GetRangeQueryParams)
	// Get Rules for a tenant in JSON form
	// (GET /api/metrics/v1/{tenant}/api/v1/rules)
	GetRules(w http.ResponseWriter, r *http.Request, tenant string, params GetRulesParams)
	// Lists all configured rules for a tenant in YAML form
	// (GET /api/metrics/v1/{tenant}/api/v1/rules/raw)
	GetRawRules(w http.ResponseWriter, r *http.Request, tenant string)
	// Set/overwrite the rules for a tenant
	// (PUT /api/metrics/v1/{tenant}/api/v1/rules/raw)
	SetRawRules(w http.ResponseWriter, r *http.Request, tenant string)
	// Get series for a tenant
	// (GET /api/metrics/v1/{tenant}/api/v1/series)
	GetSeries(w http.ResponseWriter, r *http.Request, tenant string, params GetSeriesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetLabelValues operation middleware
func (siw *ServerInterfaceWrapper) GetLabelValues(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "label_name" -------------
	var labelName string

	err = runtime.BindStyledParameter("simple", false, "label_name", chi.URLParam(r, "label_name"), &labelName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "label_name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLabelValuesParams

	// ------------- Optional query parameter "match[]" -------------
	if paramValue := r.URL.Query().Get("match[]"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "match[]", r.URL.Query(), &params.Match)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "match[]", Err: err})
		return
	}

	// ------------- Optional query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Optional query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabelValues(w, r, tenant, labelName, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLabels operation middleware
func (siw *ServerInterfaceWrapper) GetLabels(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLabelsParams

	// ------------- Optional query parameter "match[]" -------------
	if paramValue := r.URL.Query().Get("match[]"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "match[]", r.URL.Query(), &params.Match)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "match[]", Err: err})
		return
	}

	// ------------- Optional query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Optional query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabels(w, r, tenant, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetInstantQuery operation middleware
func (siw *ServerInterfaceWrapper) GetInstantQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInstantQueryParams

	// ------------- Optional query parameter "query" -------------
	if paramValue := r.URL.Query().Get("query"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "time" -------------
	if paramValue := r.URL.Query().Get("time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	// ------------- Optional query parameter "timeout" -------------
	if paramValue := r.URL.Query().Get("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", r.URL.Query(), &params.Timeout)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timeout", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInstantQuery(w, r, tenant, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRangeQuery operation middleware
func (siw *ServerInterfaceWrapper) GetRangeQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRangeQueryParams

	// ------------- Optional query parameter "query" -------------
	if paramValue := r.URL.Query().Get("query"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Optional query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	// ------------- Optional query parameter "step" -------------
	if paramValue := r.URL.Query().Get("step"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "step", r.URL.Query(), &params.Step)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "step", Err: err})
		return
	}

	// ------------- Optional query parameter "timeout" -------------
	if paramValue := r.URL.Query().Get("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", r.URL.Query(), &params.Timeout)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timeout", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRangeQuery(w, r, tenant, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRules operation middleware
func (siw *ServerInterfaceWrapper) GetRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "match[]" -------------
	if paramValue := r.URL.Query().Get("match[]"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "match[]", r.URL.Query(), &params.Match)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "match[]", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRules(w, r, tenant, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawRules operation middleware
func (siw *ServerInterfaceWrapper) GetRawRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawRules(w, r, tenant)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRawRules operation middleware
func (siw *ServerInterfaceWrapper) SetRawRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRawRules(w, r, tenant)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSeries operation middleware
func (siw *ServerInterfaceWrapper) GetSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant string

	err = runtime.BindStyledParameter("simple", false, "tenant", chi.URLParam(r, "tenant"), &tenant)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSeriesParams

	// ------------- Optional query parameter "match[]" -------------
	if paramValue := r.URL.Query().Get("match[]"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "match[]", r.URL.Query(), &params.Match)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "match[]", Err: err})
		return
	}

	// ------------- Optional query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Optional query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSeries(w, r, tenant, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/label/{label_name}/values", wrapper.GetLabelValues)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/labels", wrapper.GetLabels)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/query", wrapper.GetInstantQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/query_range", wrapper.GetRangeQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/rules", wrapper.GetRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/rules/raw", wrapper.GetRawRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/rules/raw", wrapper.SetRawRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/metrics/v1/{tenant}/api/v1/series", wrapper.GetSeries)
	})

	return r
}
